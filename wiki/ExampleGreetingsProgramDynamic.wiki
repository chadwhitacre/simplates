=Example: Greetings, program! (Dynamic)=

We want these:

{{{
http://www.example.com/greetings/Python/
http://www.example.com/greetings/Django/
http://www.example.com/greetings/Perl/
}}}

To all be served by:

{{{
/path/to/simplates/greetings/program.html
}}}

And we want the output to vary based on the URL:

{{{
Greetings, Python!
Greetings, Django!
Greetings, Perl!
}}}


* settings.py

{{{
SIMPLATE_DIRS = (
     '/path/to/simplates',
)
}}}


* urls.py

{{{

from django.conf.urls.defaults import *
from simplates.views import direct_to_simplate


urlpatterns = patterns('',
    ( r'^greetings/(?P<program>[^/]+)/$'
    , direct_to_simplate)
    , {'simplate':'greetings/program.html'}
     )
)

}}}


* simplate at /path/to/simplates/greetings/program.html:

Our simplate has two sections, separated by this line:

{{{
#<!--===BREAK===-->
}}}

This token is chosen so that it is syntax-highlighted as a comment in your editor whether you are using HTML or Python highlighting (to work efficiently with simplates, you'll want to set up a key mapping in your editor to quickly switch between these highlighting modes).

Think of the first section as a Django view, and the second section as a Django template. Any objects you define in the first section (the view) become part of the context for the second (the template).

Here is the content of the simplate:

{{{
try:
    # The values from the regex in urls.py are available in a 'params' dictionary.
    program = params['program'] 
except KeyError:
    program = 'program'

#<!--===BREAK===-->
<p>Greetings, {{ program }}!</p>
}}}